# 观察者模式



## 使用proxy 实现观察者模式

```javascript
let queuedObservers = new Set();

const observe = fn => queuedObservers.add(fn);	// 观察这个行为的函数，例如 observe(a)表示有一个观察者观察 a 这个 object
const observable = obj => new Proxy(obj, {set}); // 被观察对象实例

function set(target, key, value, receiver) {
  const result = Reflect.set(target, key, value, receiver);
  queuedObservers.forEach(observer => observer(key)); // 注意这里有参数 key
  return result;
}

// 这里的观察者也有参数 key，上面的 observer(key) 其实就是 obs1(key) 和 obs2(key)
let obs1 = key => console.log(`key ${key} will change, this is ob1`); //定义观察者1号
let obs2 = key => console.log(`key ${key} will change, this is ob2`); //定义观察者2号

observe(obs1) //相当于queuedObservers.add(obs1)
observe(obs2) //相当于queuedObservers.add(obs2)
// 注意这里 obs1和 obs2是观察者，而不是被观察对象。

let obj = observable({key1: 111, key2: 222})
obj.key1 = 3 
// key key1 will change, this is ob1
// key key2 will change, this is ob2

// 这样一来，对数据一有变动，那么观察者就会立刻发现。
```

上面的代码实现的就是观察者模式